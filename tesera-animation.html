<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TESERA Tile Animation</title>
<style>
  body {
    background:#ffffff;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    margin:0;
  }

  svg { width: 900px; }

  .tile {
    transition: fill 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* Color tokens */
  .g1 { fill:#E6E6E8; }
  .g2 { fill:#DADADD; }
  .blue { fill:#0072CE; }
  .yellow { fill:#FFC325; }
</style>
</head>
<body>

<svg viewBox="0 0 874 434">
  <g id="grid"></g>
</svg>

<script>
const cols = 40;
const rows = 20;
const size = 16;
const gap = 6;

const grid = document.getElementById("grid");

// --- Build grid ---
const tileMap = {};
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x", c * (size + gap));
    rect.setAttribute("y", r * (size + gap));
    rect.setAttribute("width", size);
    rect.setAttribute("height", size);
    rect.setAttribute("class", `tile ${(r + c) % 2 === 0 ? "g1":"g2"}`);
    grid.appendChild(rect);
    tileMap[r+","+c] = rect;
  }
}

function tileAt(r,c){ return tileMap[r+","+c]; }

// --- Bitmap font (5 wide × 7 tall) ---
// Each letter is an array of 7 strings, each 5 chars wide
// 1 = filled, 0 = empty
const font = {
  T: [
    "11111",
    "00100",
    "00100",
    "00100",
    "00100",
    "00100",
    "00100",
  ],
  E: [
    "11111",
    "10000",
    "10000",
    "11110",
    "10000",
    "10000",
    "11111",
  ],
  S: [
    "11111",
    "10000",
    "10000",
    "11111",
    "00001",
    "00001",
    "11111",
  ],
  R: [
    "11110",
    "10001",
    "10001",
    "11110",
    "10100",
    "10010",
    "10001",
  ],
  A: [
    "01110",
    "10001",
    "10001",
    "11111",
    "10001",
    "10001",
    "10001",
  ],
};

// --- Spell TESERA, centred in the 40×20 grid ---
const word = "TESERA";
const letterW = 5;
const letterH = 7;
const gapBetween = 1; // 1-col gap between letters
const totalW = word.length * letterW + (word.length - 1) * gapBetween; // 35
const startCol = Math.floor((cols - totalW) / 2); // 2 or 3
const startRow = Math.floor((rows - letterH) / 2); // 6 or 7

// Build blue coordinates from bitmaps
const blueTiles = [];
for (let li = 0; li < word.length; li++) {
  const letter = font[word[li]];
  const colOff = startCol + li * (letterW + gapBetween);
  for (let dr = 0; dr < letterH; dr++) {
    for (let dc = 0; dc < letterW; dc++) {
      if (letter[dr][dc] === "1") {
        blueTiles.push([startRow + dr, colOff + dc]);
      }
    }
  }
}

// Two yellow blocks per letter — all on the same row (top row, last two filled tiles)
const yellowRow = startRow; // top row of every letter
const yellowTiles = [];
for (let li = 0; li < word.length; li++) {
  const letter = font[word[li]];
  const colOff = startCol + li * (letterW + gapBetween);
  // Find the rightmost two filled cells in the top row
  const filled = [];
  for (let dc = 0; dc < letterW; dc++) {
    if (letter[0][dc] === "1") filled.push(colOff + dc);
  }
  // Take last two
  yellowTiles.push([yellowRow, filled[filled.length - 2]]);
  yellowTiles.push([yellowRow, filled[filled.length - 1]]);
}

// --- Sort by column so animations sweep left → right ---
blueTiles.sort((a,b) => a[1] - b[1]);
yellowTiles.sort((a,b) => a[1] - b[1]);

// --- Animate sequence ---
setTimeout(() => {
  blueTiles.forEach(([r,c],i) => {
    setTimeout(() => {
      const t = tileAt(r,c);
      if (t) t.setAttribute("class","tile blue");
    }, i * 25);
  });
}, 600);

const blueEnd = 600 + blueTiles.length * 25;
setTimeout(() => {
  yellowTiles.forEach(([r,c],i) => {
    setTimeout(() => {
      const t = tileAt(r,c);
      if (t) t.setAttribute("class","tile yellow");
    }, i * 80);
  });
}, blueEnd + 400);
</script>

</body>
</html>
