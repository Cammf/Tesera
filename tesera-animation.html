<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TESERA Tile Animation</title>
<style>
  body {
    background:#ffffff;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    margin:0;
  }

  svg { width: 900px; }

  .tile {
    transition: fill 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* Color tokens */
  .g1 { fill:#E6E6E8; }
  .g2 { fill:#DADADD; }
  .blue { fill:#0072CE; }
  .yellow { fill:#FFC325; }
</style>
</head>
<body>

<svg viewBox="0 0 874 434">
  <g id="grid"></g>
</svg>

<script>
const cols = 40;
const rows = 20;
const size = 16;
const gap = 6;

const grid = document.getElementById("grid");

// --- Build grid ---
let tiles = [];
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x", c * (size + gap));
    rect.setAttribute("y", r * (size + gap));
    rect.setAttribute("width", size);
    rect.setAttribute("height", size);
    rect.setAttribute("class", `tile ${Math.random() > 0.5 ? "g1":"g2"}`);
    grid.appendChild(rect);
    tiles.push({ r, c, rect });
  }
}

// --- Helper ---
function tileAt(r,c){
  return tiles.find(t => t.r === r && t.c === c)?.rect;
}

// --- Letter definitions (5 wide x 7 tall, centred vertically) ---
// Grid is 20 rows; letters are 7 tall → start row = (20-7)/2 = 6 (row 6-12)
// Grid is 40 cols; 6 letters × 5 wide + 5 gaps × 1 = 35 → start col = (40-35)/2 ≈ 3
const tr = 7; // top row of letters

// Column offsets for each letter (5 wide + 1 gap = 6 apart)
const tC=3, eC=9, sC=15, e2C=21, rC=27, aC=33;

const blue = [
  // T — top bar + stem
  [tr,tC],[tr,tC+1],[tr,tC+2],[tr,tC+3],[tr,tC+4],
  [tr+1,tC+2],[tr+2,tC+2],[tr+3,tC+2],[tr+4,tC+2],[tr+5,tC+2],[tr+6,tC+2],

  // E — left spine + three bars
  [tr,eC],[tr,eC+1],[tr,eC+2],[tr,eC+3],[tr,eC+4],
  [tr+1,eC],[tr+2,eC],
  [tr+3,eC],[tr+3,eC+1],[tr+3,eC+2],[tr+3,eC+3],
  [tr+4,eC],[tr+5,eC],
  [tr+6,eC],[tr+6,eC+1],[tr+6,eC+2],[tr+6,eC+3],[tr+6,eC+4],

  // S — top bar, left, middle bar, right, bottom bar
  [tr,sC],[tr,sC+1],[tr,sC+2],[tr,sC+3],[tr,sC+4],
  [tr+1,sC],[tr+2,sC],
  [tr+3,sC],[tr+3,sC+1],[tr+3,sC+2],[tr+3,sC+3],[tr+3,sC+4],
  [tr+4,sC+4],[tr+5,sC+4],
  [tr+6,sC],[tr+6,sC+1],[tr+6,sC+2],[tr+6,sC+3],[tr+6,sC+4],

  // E2
  [tr,e2C],[tr,e2C+1],[tr,e2C+2],[tr,e2C+3],[tr,e2C+4],
  [tr+1,e2C],[tr+2,e2C],
  [tr+3,e2C],[tr+3,e2C+1],[tr+3,e2C+2],[tr+3,e2C+3],
  [tr+4,e2C],[tr+5,e2C],
  [tr+6,e2C],[tr+6,e2C+1],[tr+6,e2C+2],[tr+6,e2C+3],[tr+6,e2C+4],

  // R — left spine, top loop, middle bar, diagonal leg
  [tr,rC],[tr,rC+1],[tr,rC+2],[tr,rC+3],
  [tr+1,rC],[tr+1,rC+4],
  [tr+2,rC],[tr+2,rC+4],
  [tr+3,rC],[tr+3,rC+1],[tr+3,rC+2],[tr+3,rC+3],
  [tr+4,rC],[tr+4,rC+2],
  [tr+5,rC],[tr+5,rC+3],
  [tr+6,rC],[tr+6,rC+4],

  // A — peak, sides, middle bar
  [tr,aC+1],[tr,aC+2],[tr,aC+3],
  [tr+1,aC],[tr+1,aC+4],
  [tr+2,aC],[tr+2,aC+4],
  [tr+3,aC],[tr+3,aC+1],[tr+3,aC+2],[tr+3,aC+3],[tr+3,aC+4],
  [tr+4,aC],[tr+4,aC+4],
  [tr+5,aC],[tr+5,aC+4],
  [tr+6,aC],[tr+6,aC+4],
];

// Two yellow blocks per letter, all at the same row (top row of each letter)
const yellowRow = tr;
const yellowTiles = [
  [yellowRow, tC+3],  [yellowRow, tC+4],   // T
  [yellowRow, eC+3],  [yellowRow, eC+4],   // E
  [yellowRow, sC+3],  [yellowRow, sC+4],   // S
  [yellowRow, e2C+3], [yellowRow, e2C+4],  // E2
  [yellowRow, rC+2],  [yellowRow, rC+3],   // R
  [yellowRow, aC+2],  [yellowRow, aC+3],   // A
];

// --- Animate sequence ---
setTimeout(() => {
  blue.forEach(([r,c],i)=>{
    setTimeout(()=>{
      const t = tileAt(r,c);
      if(t){ t.setAttribute("class","tile blue"); }
    }, i*30);
  });
}, 600);

setTimeout(() => {
  yellowTiles.forEach(([r,c])=>{
    const t = tileAt(r,c);
    if(t){ t.setAttribute("class","tile yellow"); }
  });
}, 600 + blue.length*30 + 400);
</script>

</body>
</html>
