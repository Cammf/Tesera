<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>TESERA Tile Animation – Compact</title>
<style>
  body {
    background:#ffffff;
    display:flex;
    justify-content:center;
    align-items:center;
    height:100vh;
    margin:0;
  }

  svg { width: 900px; }

  .tile {
    transition: fill 0.4s cubic-bezier(0.4, 0.0, 0.2, 1);
  }

  /* Color tokens */
  .g1 { fill:#E6E6E8; }
  .g2 { fill:#DADADD; }
  .blue { fill:#0072CE; }
  .yellow { fill:#FFC325; }
</style>
</head>
<body>

<svg viewBox="0 0 874 434">
  <g id="grid"></g>
</svg>

<script>
const cols = 40;
const rows = 20;
const size = 16;
const gap = 6;

const grid = document.getElementById("grid");

// --- Build grid ---
const tileMap = {};
for (let r = 0; r < rows; r++) {
  for (let c = 0; c < cols; c++) {
    const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
    rect.setAttribute("x", c * (size + gap));
    rect.setAttribute("y", r * (size + gap));
    rect.setAttribute("width", size);
    rect.setAttribute("height", size);
    rect.setAttribute("class", `tile ${(r + c) % 2 === 0 ? "g1":"g2"}`);
    grid.appendChild(rect);
    tileMap[r+","+c] = rect;
  }
}

function tileAt(r,c){ return tileMap[r+","+c]; }

// --- Compact bitmap font (2 wide × 3 tall) ---
// Each letter uses only 1-2 blocks per row across 3 rows
const font = {
  T: [
    "11",
    "01",
    "01",
  ],
  E: [
    "11",
    "10",
    "11",
  ],
  S: [
    "11",
    "01",
    "11",
  ],
  R: [
    "11",
    "11",
    "10",
  ],
  A: [
    "11",
    "11",
    "10",
  ],
};

// --- Spell TESERA, centred in the 40×20 grid ---
const word = "TESERA";
const letterW = 2;
const letterH = 3;
const gapBetween = 1; // 1-col gap between letters
const totalW = word.length * letterW + (word.length - 1) * gapBetween; // 17
const startCol = Math.floor((cols - totalW) / 2);
const startRow = Math.floor((rows - letterH) / 2);

// Build blue coordinates from bitmaps
const blueTiles = [];
for (let li = 0; li < word.length; li++) {
  const letter = font[word[li]];
  const colOff = startCol + li * (letterW + gapBetween);
  for (let dr = 0; dr < letterH; dr++) {
    for (let dc = 0; dc < letterW; dc++) {
      if (letter[dr][dc] === "1") {
        blueTiles.push([startRow + dr, colOff + dc]);
      }
    }
  }
}

// Two yellow blocks per letter — all on the same row (top row)
const yellowRow = startRow;
const yellowTiles = [];
for (let li = 0; li < word.length; li++) {
  const letter = font[word[li]];
  const colOff = startCol + li * (letterW + gapBetween);
  const filled = [];
  for (let dc = 0; dc < letterW; dc++) {
    if (letter[0][dc] === "1") filled.push(colOff + dc);
  }
  yellowTiles.push([yellowRow, filled[filled.length - 2]]);
  yellowTiles.push([yellowRow, filled[filled.length - 1]]);
}

// --- Remove yellow positions from blue so they don't render as blue first ---
const yellowSet = new Set(yellowTiles.map(([r,c]) => r+","+c));
const blueOnly = blueTiles.filter(([r,c]) => !yellowSet.has(r+","+c));

// --- Group tiles by column for column-at-a-time wave ---
function groupByCol(arr) {
  const map = {};
  arr.forEach(([r,c]) => { (map[c] = map[c] || []).push([r,c]); });
  return Object.keys(map).sort((a,b) => a - b).map(k => map[k]);
}

const blueCols = groupByCol(blueOnly);
const yellowCols = groupByCol(yellowTiles);

// --- Animation 1: blue wave, entire column at once, 80ms between columns ---
setTimeout(() => {
  blueCols.forEach((tiles, ci) => {
    setTimeout(() => {
      tiles.forEach(([r,c]) => {
        const t = tileAt(r,c);
        if (t) t.setAttribute("class","tile blue");
      });
    }, ci * 80);
  });
}, 600);

const blueEnd = 600 + blueCols.length * 80;

// --- Animation 2: yellow wave, entire column at once, 80ms between columns ---
setTimeout(() => {
  yellowCols.forEach((tiles, ci) => {
    setTimeout(() => {
      tiles.forEach(([r,c]) => {
        const t = tileAt(r,c);
        if (t) t.setAttribute("class","tile yellow");
      });
    }, ci * 80);
  });
}, blueEnd + 400);
</script>

</body>
</html>
